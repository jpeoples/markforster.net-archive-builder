<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Optimal stopping secretaryÂ problem</title>
    <link rel="stylesheet" href="../style.css">
</head>
<body>
    <header>
        <nav>
            <a href="../index.html">Home</a>
            <a href="../blog_index.html">Blog</a>
            <a href="../fvp_forum_index.html">FVP Forum</a>
            <a href="../general_forum_index.html">General Forum</a>
        </nav>
    </header>
    <main>
<article>
<h1>Optimal stopping secretaryÂ problem</h1>
<div class="meta">
Author: John W | 
Created: 2020-05-1 12:36
 | Last Activity: 2020-05-6 11:36
</div>
<h2>Original Post</h2>
<div class="meta">2020-05-1 12:36</div>
<div class="content">I recently read algorithms to live by, and just started rereading it when it occurred to me that the optimal stopping could be used with task selection so I tried it out. In a nut shell, when you want to choose the best option from a known total number of options, you can find the best option by always calibrating with the first 37% of options and not selecting any of them. After getting past the first 37% you then select any task that you want to do more than anything that was in the first 37%. <br><br>Anyway, I am taking in trying to apply this to my list which is getting way too long and I find it helpful. I won't go into details about how I do it because it's not rigid, but it means I scan more tasks without the pressure of having to do them which is interesting, because before I was never getting to the end of my list. <br><br>Anyway, curious to see if anyone else thinks this or anything else in the book might be useful additions to Mark Forster's systems.</div>
<h2>Reply by Voluntas</h2>
<div class="meta">2020-05-1 17:17</div>
<div class="content">How do you propose to get any work done on the first 37% of your list?</div>
<h2>Reply by John W</h2>
<div class="meta">2020-05-2 10:05</div>
<div class="content">Well I just start again from my last task I worked on. I use dynalist which can do numbered lists so I just do quick maths.  Or if I don't want to keep doing it over and over I can work off a time period like a Pomodoro, after which I will review the list from my latest prices point. This is why I didn't go into detail. ðŸ™‚ But I thought it was very interesting. The really interesting thing for me was being able to scan the just without the pressure of thinking I should choose one to do now.  Also, by scanning a few more items I had a better feel for what I was comparing to instead of one task.</div>
<h2>Reply by Voluntas</h2>
<div class="meta">2020-05-2 19:08</div>
<div class="content">The way I understand you is that, after completing a task, you scan the next 37% of entries to "set the bar", then select your next task from the other 63%. This is pretty interesting, and if it works for you, then of course continue.<br><br>TL;DR - I encourage you to continue this experiment. If it works, it works. However, I discourage you from assuming that because an algorithm is optimal in one problem domain, it remains optimal over a different domain.<br><br>I don't intend to put down your effort in any way. But being a programming hobbyist myself, I have spent some time thinking about the differences between Mark's algorithms and the canonical algorithms from computer science. Essentially Mark's algorithms are designed to sort a data structure whose contents may change at any time (we can add, modify or delete entries as we see fit). Most sorting algorithms for computers are designed to work on a data structure which cannot change until after the sort has completed.<br><br>There are a few assumptions built into the secretary problem that don't apply to your approach. First, the secretary problem assumes that if you choose not to hire a candidate (in your case, choose not to action a list item) __you can't return to that candidate later__. FV's assumption is that you will revisit your list items many times. Second, the secretary problem assumes that it is always possible to consider __every__ candidate. While it is highly unlikely that someone would __never __ reach the end of their TM list, it's still a possibility. For instance, when the task "Process email" comes up for me, I often add 2 or more items to my list, but only check off 1 ("Process email"), so the list grows faster than I consume it. There might be other mismatches between the algorithms, but I haven't dug in that deeply yet.<br><br>I'm interested to know where your experiment takes you. If you have any questions about the details I've mentioned, I'll be happy to discuss.</div>
<h2>Reply by John W</h2>
<div class="meta">2020-05-6 7:45</div>
<div class="content">Voluntas, I appreciate the detailed response.  "setting the bar" is exactly what is happening, that is a good choice of words.  <br><br>Yes, I do understand that my list is not limited to a one-shot-only passthrough.  One of the things I am finding is that I am not getting to my bottom of my list (or even bothering to go to the start of my list) because it is too long and it feels like a drag, so this was a way for me to engage with my list without the pressure of not wanting to do anything.  If I was actually going through my list multiple times a day, then this idea probably wouldn't get as much attention from me.  <br><br>Another thing is because I am able to do multiple run throughs, then sticking to 37% is not exactly important.  The real discovery for me is using muptiple tasks to set the bar.  I could make this ten task or any other number that suits me best, which I will experiment with.  Having the simple sample of 10 items for example, makes it much easier to count them off and get to the next part of the list instead of calculating 37%, which I do not really think is all that important because of the multiple run throughs.    <br><br>The other application of this is weeding lists.  <br><br>I can run through 37% (or any other number) of tasks to set the bar, and then ask "what is the most deletable item on this list?"  with the remaining tasks.  Or any other question...  Off the top of my head..   "What has the least consequence?"  "What are you likely to resist for ever on this list?"  "what do I want to do least?"  "what task has the most pressure associated with it?"  etc   <br><br>So as I mentioned, I do not have this finely tuned or anything, I just like discussing its merits or lack thereof.<br><br>Cheers</div>
<h2>Reply by Chris Cooper</h2>
<div class="meta">2020-05-6 8:51</div>
<div class="content">There's been a fair amount of discussion on this site of this rule (or similar), under the heading "Colley's Rule".</div>
<h2>Reply by John W</h2>
<div class="meta">2020-05-6 9:05</div>
<div class="content">Hi Chris,<br><br>Yes I did do some research on that in these forums, which is what led me to try applying the 37% instead of just one item.  And as mentioned, the main unexpected benefits are  <br><br>- I am more familiar with my list because I can scan over a number of items without the pressure of having to do them, instead, the inital scan is just used to set the bar. <br><br>- less resistance to the list - for the same reasons as above.  <br><br>- I also have a better feel for where the bar is, taking into account varying factors that are difficult to put into words (why the original FVP used the "want to do" question).  This makes it easier for me to decide what I "want" to do more.     <br><br>- and lastly, just by thinking about my main problem (list resistance) has led me to apply the same process for weeding of the list.  <br><br><br>Cheers</div>
<h2>Reply by Mark Forster</h2>
<div class="meta">2020-05-6 11:36</div>
<div class="content">It occurs to me that ASEM obtains much the same result but is easier to use. This has always been one of my favourite methods.<br><br><a href="../blog/Reviewing an Old Favourite.html" target="new" rel="nofollow">http://markforster.squarespace.com/blog/2018/11/18/reviewing-an-old-favourite.html</a></div>
</article>
    </main>
    <footer>
        <p>Archive built from Mark Forster's blog and forums</p>
    </footer>
</body>
</html>